#pragma once
#include "Engine/Common.h"
#include "Engine/Material.h"
#include "Engine/Texture.h"
#include "Engine/StaticMesh.h"

#define BLOCK_MESH_MAX_BLOCK_TYPES 0xFF

enum BLOCK_MESH_BLOCK_TYPE_FLAG
{
    BLOCK_MESH_BLOCK_TYPE_FLAG_SOLID                     = (1 << 0),
    BLOCK_MESH_BLOCK_TYPE_FLAG_CAST_SHADOWS              = (1 << 2),
    BLOCK_MESH_BLOCK_TYPE_FLAG_CUBE_SHAPE_VOLUME         = (1 << 3),
    BLOCK_MESH_BLOCK_TYPE_FLAG_CUBE_SHAPE_UNTILEABLE     = (1 << 4),

    // autogenerated flags
    BLOCK_MESH_BLOCK_TYPE_FLAG_BLOCK_LIGHT_EMITTER       = (1 << 27),
    BLOCK_MESH_BLOCK_TYPE_FLAG_POINT_LIGHT_EMITTER       = (1 << 28),
    BLOCK_MESH_BLOCK_TYPE_FLAG_VISIBLE                   = (1 << 29),
    BLOCK_MESH_BLOCK_TYPE_FLAG_BLOCKS_VISIBILITY         = (1 << 30),
    BLOCK_MESH_BLOCK_TYPE_FLAG_COLLIDABLE                = (1 << 31),
};

enum BLOCK_MESH_BLOCK_TYPE_SHAPE_TYPE
{
    BLOCK_MESH_BLOCK_TYPE_SHAPE_TYPE_NONE,
    BLOCK_MESH_BLOCK_TYPE_SHAPE_TYPE_CUBE,
    BLOCK_MESH_BLOCK_TYPE_SHAPE_TYPE_SLAB,
    BLOCK_MESH_BLOCK_TYPE_SHAPE_TYPE_STAIRS,
    BLOCK_MESH_BLOCK_TYPE_SHAPE_TYPE_PLANE,
    BLOCK_MESH_BLOCK_TYPE_SHAPE_TYPE_MESH,
    BLOCK_MESH_BLOCK_TYPE_SHAPE_TYPE_COUNT,
};

enum BLOCK_MESH_BLOCK_TYPE_VISUAL_TYPE
{
    BLOCK_MESH_BLOCK_TYPE_VISUAL_TYPE_COLOR,
    BLOCK_MESH_BLOCK_TYPE_VISUAL_TYPE_TEXTURE,
    BLOCK_MESH_BLOCK_TYPE_VISUAL_TYPE_MATERIAL,
    BLOCK_MESH_BLOCK_TYPE_VISUAL_TYPE_COUNT,
};

enum BLOCK_MESH_TEXTURE_BLENDING
{
    BLOCK_MESH_TEXTURE_BLENDING_NONE,
    BLOCK_MESH_TEXTURE_BLENDING_MASKED,
    BLOCK_MESH_TEXTURE_BLENDING_TRANSLUCENT,
    BLOCK_MESH_TEXTURE_BLENDING_COUNT,
};

enum BLOCK_MESH_TEXTURE_EFFECT
{
    BLOCK_MESH_TEXTURE_EFFECT_NONE,
    BLOCK_MESH_TEXTURE_EFFECT_SCROLL,
    BLOCK_MESH_TEXTURE_EFFECT_ANIMATION,
    BLOCK_MESH_TEXTURE_EFFECT_COUNT,
};

class BlockPaletteGenerator;

class BlockPalette : public Resource
{
public:
    struct BlockType
    {
        bool IsAllocated;
        uint32 BlockTypeIndex;
        String Name;
        uint32 Flags;
        BLOCK_MESH_BLOCK_TYPE_SHAPE_TYPE ShapeType;

        struct VisualParameters
        {
            BLOCK_MESH_BLOCK_TYPE_VISUAL_TYPE Type;
            uint32 MaterialIndex;
            uint32 Color;
            float3 MinUV;
            float3 MaxUV;
            float4 AtlasUVRange;
        };

        struct CubeShapeFace
        {
            VisualParameters Visual;
        };

        struct SlabShape
        {
            float Height;
        };

        struct PlaneShape
        {
            VisualParameters Visual;

            // these are 0-1 factors
            float OffsetX;
            float OffsetY;
            float Width;
            float Height;

            // in degrees
            float BaseRotation;
            uint32 RepeatCount;
            float RepeatRotation;
        };

        struct MeshShape
        {
            uint32 MeshIndex;
            float Scale;
        };

        struct BlockLightEmitter
        {
            uint32 Radius;
        };

        struct PointLightEmitter
        {
            float3 Offset;
            uint32 Color;
            float Brightness;
            float Range;
            float Falloff;
        };

        CubeShapeFace CubeShapeFaces[CUBE_FACE_COUNT];
        SlabShape SlabShapeSettings;
        PlaneShape PlaneShapeSettings;
        MeshShape MeshShapeSettings;
        BlockLightEmitter BlockLightEmitterSettings;
        PointLightEmitter PointLightEmitterSettings;
    };

public:
    BlockPalette();
    ~BlockPalette();

    // serialization
    bool Load(const char *FileName, ByteStream *pStream);

    // accessors
    const BlockPalette::BlockType *GetBlockType(uint32 i) const { DebugAssert(i < BLOCK_MESH_MAX_BLOCK_TYPES); return &m_BlockTypes[i]; }
    const Texture *GetTexture(uint32 i) const { DebugAssert(i < m_textures.GetSize()); return m_textures[i]; }
    const uint32 GetTextureCount() const { return m_textures.GetSize(); }
    const Material *GetMaterial(uint32 i) const { DebugAssert(i < m_materials.GetSize()); return m_materials[i]; }
    const uint32 GetMaterialCount() const { return m_materials.GetSize(); }
    const StaticMesh *GetMesh(uint32 i) const { DebugAssert(i < m_meshes.GetSize()); return m_meshes[i]; }
    const uint32 GetMeshCount() const { return m_meshes.GetSize(); }

    // find block type by name
    const BlockPalette::BlockType *GetBlockTypeByName(const char *name) const;

    // gpu resources
    bool CreateGPUResources() const;
    void ReleaseGPUResources() const;

private:
    BlockPalette::BlockType m_BlockTypes[BLOCK_MESH_MAX_BLOCK_TYPES];
    PODArray<const Texture *> m_textures;
    PODArray<const Material *> m_materials;
    PODArray<const StaticMesh *> m_meshes;
};

